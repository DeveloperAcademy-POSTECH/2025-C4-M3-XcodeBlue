//
//  DashboardViewModel.swift
//  TarTanning
//
//  Created by taeni on 7/25/25.
//

import Foundation
import SwiftUI
import SwiftData

@MainActor
final class DashboardViewModel: ObservableObject {
    
    // MARK: - Published Properties (UI State)
    @Published var todayMEDProgress: Double = 0.0
    @Published var weeklyMEDProgress: [Double] = []
    @Published var currentUVIndex: Int = 0
    @Published var currentTemperature: Int = 0
    @Published var todayTotalSunlightMinutes: Int = 0
    
    @Published var isLoading = false
    @Published var errorMessage: String?
    
    // MARK: - Dependencies
    // TODO: - UVExposureService Í∏∞Îä• Íµ¨ÌòÑ ÌõÑ Ï†ÅÏö©
//    private let uvService = UVExposureService.shared
    private var modelContext: ModelContext?
    
    // MARK: - User Settings
    private var userSkinType: SkinType {
        let rawValue = UserDefaults.standard.integer(forKey: "selectedSkinType")
        return SkinType(rawValue: rawValue) ?? .type3
    }
    
    // MARK: - Computed Properties for UI
    var todayMEDPercentage: Int {
        Int(todayMEDProgress * 100)
    }
    
    var uvStatusText: String {
        switch todayMEDProgress {
        case 0.0..<0.3: return "ÏïàÏ†Ñ"
        case 0.3..<0.5: return "Ï£ºÏùò"
        case 0.5..<0.7: return "ÏúÑÌóò"
        default: return "Îß§Ïö∞ ÏúÑÌóò"
        }
    }
    
    var uvStatusColor: Color {
        switch todayMEDProgress {
        case 0.0..<0.3: return .blue
        case 0.3..<0.5: return .orange
        case 0.5..<0.7: return .red
        default: return .red
        }
    }
    
    var uvAdviceText: String {
        switch todayMEDProgress {
        case 0.0..<0.3: return "Ï†ÅÎãπÌïú ÏïºÏô∏ÌôúÎèôÏùÑ Ï¶êÍ∏∞ÏÑ∏Ïöî!"
        case 0.3..<0.5: return "ÏûêÏô∏ÏÑ† Ï∞®Îã®Ï†úÎ•º ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî!"
        case 0.5..<0.7: return "ÏïºÏô∏ÌôúÎèôÏùÑ ÏûêÏ†úÌïòÏÑ∏Ïöî!"
        default: return "Ï¶âÏãú Ïã§ÎÇ¥Î°ú Ïù¥ÎèôÌïòÏÑ∏Ïöî!"
        }
    }
    
    // MARK: - Initialization
    func configure(with modelContext: ModelContext) {
        self.modelContext = modelContext
    }
    
    // MARK: - Main Data Loading
    func loadDashboardData() async {
        guard !isLoading else { return }
        
        isLoading = true
        errorMessage = nil
        
        do {
            // 1. Ïò§ÎäòÏùò MED ÏßÑÌñâÎ•† Í∞ÄÏ†∏Ïò§Í∏∞
            
            // TODO: - UVExposureService Í∏∞Îä• Íµ¨ÌòÑ ÌõÑ Ï†ÅÏö©
//            let todayProgress = await uvService.getCurrentMEDProgress()
            
            // 2. Ï£ºÍ∞Ñ MED ÏßÑÌñâÎ•† Í∞ÄÏ†∏Ïò§Í∏∞
            let weeklyProgress = try await fetchWeeklyMEDProgress()
            
            // 3. Ïò§ÎäòÏùò ÏùºÍ¥ëÏãúÍ∞Ñ Í∞ÄÏ†∏Ïò§Í∏∞
            let todaySunlight = try await fetchTodaySunlightMinutes()
            
            // 4. ÌòÑÏû¨ ÎÇ†Ïî® Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
            let (uvIndex, temperature) = try await fetchCurrentWeatherInfo()
            
            // UI ÏóÖÎç∞Ïù¥Ìä∏
            // TODO: - UVExposureService Í∏∞Îä• Íµ¨ÌòÑ ÌõÑ Ï†ÅÏö©
            self.todayMEDProgress = 0.3 //ÏûÑÏãúÏûÑ
            self.weeklyMEDProgress = weeklyProgress
            self.todayTotalSunlightMinutes = todaySunlight
            self.currentUVIndex = uvIndex
            self.currentTemperature = temperature
            
        } catch {
            errorMessage = "Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ïã§Ìå®: \(error.localizedDescription)"
        }
        
        isLoading = false
    }
    
    // MARK: - Refresh Data
    func refreshData() async {
        // UV ÏÑúÎπÑÏä§ ÏàòÎèô ÏóÖÎç∞Ïù¥Ìä∏ ÌõÑ ÎåÄÏãúÎ≥¥Îìú Îç∞Ïù¥ÌÑ∞ Îã§Ïãú Î°úÎìú
        // TODO: - UVExposureService Í∏∞Îä• Íµ¨ÌòÑ ÌõÑ Ï†ÅÏö©
//        await uvService.manualRefresh()
        await loadDashboardData()
    }
    
    // MARK: - Private Data Fetching Methods
    
    /// Ï£ºÍ∞Ñ MED ÏßÑÌñâÎ•† Í∞ÄÏ†∏Ïò§Í∏∞ (ÏµúÍ∑º 7Ïùº)
    private func fetchWeeklyMEDProgress() async throws -> [Double] {
        guard let context = modelContext else { return [] }
        
        let calendar = Calendar.current
        let today = Date()
        let weekAgo = calendar.date(byAdding: .day, value: -7, to: today)!
        
        let descriptor = FetchDescriptor<DailyUVExpose>(
            predicate: #Predicate { daily in
                daily.date >= weekAgo && daily.date <= today
            },
            sortBy: [SortDescriptor(\.date, order: .forward)]
        )
        
        let weeklyData = try context.fetch(descriptor)
        let maxMED = userSkinType.maxMED
        
        // ÏµúÍ∑º 7ÏùºÍ∞ÑÏùò ÏßÑÌñâÎ•† Í≥ÑÏÇ∞ (ÏóÜÎäî ÎÇ†ÏùÄ 0ÏúºÎ°ú Ï≤òÎ¶¨)
        var progressArray: [Double] = []
        
        for dayOffset in (0..<7).reversed() {
            let targetDate = calendar.date(byAdding: .day, value: -dayOffset, to: today)!
            
            if let dailyData = weeklyData.first(where: {
                calendar.isDate($0.date, inSameDayAs: targetDate)
            }) {
                let progress = maxMED > 0 ? dailyData.totalUVDose / maxMED : 0.0
                progressArray.append(progress)
            } else {
                progressArray.append(0.0)
            }
        }
        
        return progressArray
    }
    
    /// Ïò§ÎäòÏùò Ï¥ù ÏùºÍ¥ëÏãúÍ∞Ñ Í∞ÄÏ†∏Ïò§Í∏∞
    private func fetchTodaySunlightMinutes() async throws -> Int {
        guard let context = modelContext else { return 0 }
        
        let today = Date()
        let calendar = Calendar.current
        let startOfDay = calendar.startOfDay(for: today)
        let endOfDay = calendar.date(byAdding: .day, value: 1, to: startOfDay)!

        let descriptor = FetchDescriptor<DailyUVExpose>(
            predicate: #Predicate { daily in
                daily.date >= startOfDay && daily.date < endOfDay
            }
        )
        
        if let todayData = try context.fetch(descriptor).first {
            return Int(todayData.totalSunlightMinutes)
        }
        
        return 0
    }
    
    /// ÌòÑÏû¨ ÎÇ†Ïî® Ï†ïÎ≥¥ (UV ÏßÄÏàò, Ïò®ÎèÑ) Í∞ÄÏ†∏Ïò§Í∏∞ - DailyWeatherCache ÏÇ¨Ïö©
    private func fetchCurrentWeatherInfo() async throws -> (uvIndex: Int, temperature: Int) {
        guard let context = modelContext else { return (0, 0) }
        
        // Ïò§Îäò ÎÇ†Ïî® Ï∫êÏãú Îç∞Ïù¥ÌÑ∞ Ï∞æÍ∏∞
        let today = Calendar.current.startOfDay(for: Date())
        let descriptor = FetchDescriptor<DailyWeatherCache>(
            predicate: #Predicate { weather in
                weather.currentDate >= today
            }
        )
        
        // Ïò§Îäò ÎÇ†Ïî® Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÏúºÎ©¥ ÌòÑÏû¨ ÏãúÍ∞ÑÏùò UV/Ïò®ÎèÑ Î∞òÌôò
        if let todayWeather = try context.fetch(descriptor).first {
            return (Int(todayWeather.currentUVIndex), Int(todayWeather.currentTemperature))
        }
        
        // Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ Í∏∞Î≥∏Í∞í Î∞òÌôò
        return (0, 0)
    }
    
    // MARK: - User Actions
    
    /// ÏàòÎèô ÏÉàÎ°úÍ≥†Ïπ® (Pull-to-refreshÏö©)
    func handlePullToRefresh() async {
        await refreshData()
    }
    
    /// ÏÑ†ÌÅ¨Î¶º Î™®Îìú ÏãúÏûë
    func startSunscreenMode() {
        TimerSyncManager.shared.start(duration: 120 * 60) // 2ÏãúÍ∞Ñ
    }
    
    /// ÏóêÎü¨ Î©îÏãúÏßÄ ÌÅ¥Î¶¨Ïñ¥
    func clearError() {
        errorMessage = nil
    }
    
    // MARK: - Debugging & Logging
    func logCurrentState() {
        print("=== Dashboard State ===")
        print("Ïò§Îäò MED ÏßÑÌñâÎ•†: \(todayMEDPercentage)%")
        print("Ï£ºÍ∞Ñ MED ÏßÑÌñâÎ•†: \(weeklyMEDProgress.map { Int($0 * 100) })")
        print("ÌòÑÏû¨ UV ÏßÄÏàò: \(currentUVIndex)")
        print("ÌòÑÏû¨ Ïò®ÎèÑ: \(currentTemperature)¬∞C")
        print("Ïò§Îäò ÏùºÍ¥ëÏãúÍ∞Ñ: \(todayTotalSunlightMinutes)Î∂Ñ")
        print("ÏÇ¨Ïö©Ïûê ÌîºÎ∂ÄÌÉÄÏûÖ: \(userSkinType.romanNumeral)")
        print("====================")
    }
}

// MARK: - Extensions for UI Helpers

extension DashboardViewModel {
    
    /// Ï£ºÍ∞Ñ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
    var hasWeeklyData: Bool {
        !weeklyMEDProgress.isEmpty && weeklyMEDProgress.contains { $0 > 0 }
    }
    
    /// Ïò§Îäò Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
    var hasTodayData: Bool {
        todayMEDProgress > 0 || todayTotalSunlightMinutes > 0
    }
    
    /// Î°úÎî© ÏÉÅÌÉúÍ∞Ä ÏïÑÎãåÏßÄ ÌôïÏù∏
    var isDataReady: Bool {
        !isLoading
    }
    
    /// Ï£ºÍ∞Ñ ÏöîÏïΩÏö© Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞Ï≤¥ Î∞∞Ïó¥
    var weeklyDisplayData: [WeeklyDayData] {
        return weeklyMEDProgress.enumerated().map { index, progress in
            let dayString = index == 6 ? "Ïò§Îäò" : "\(6-index)Ïùº Ï†Ñ"
            let (color, emoji) = getColorAndEmoji(for: progress)
            
            return WeeklyDayData(
                day: dayString,
                progress: progress,
                color: color,
                emoji: emoji
            )
        }
    }
    
    private func getColorAndEmoji(for progress: Double) -> (Color, String) {
        switch progress {
        case 0.0..<0.3: return (.blue, "üòÜ")
        case 0.3..<0.7: return (.orange, "üôÇ")
        case 0.7..<1.0: return (.red, "üòî")
        default: return (.black, "üî•")
        }
    }
}

// MARK: - Additional Weather Helpers

extension DashboardViewModel {
    
    /// ÌäπÏ†ï ÏãúÍ∞ÑÏùò UV ÏßÄÏàò Í∞ÄÏ†∏Ïò§Í∏∞ (UVExposureServiceÏóêÏÑú ÏÇ¨Ïö©)
    func getUVIndex(at hour: Int) async -> Double {
        guard let context = modelContext else { return 0.0 }
        
        let today = Calendar.current.startOfDay(for: Date())
        let descriptor = FetchDescriptor<DailyWeatherCache>(
            predicate: #Predicate { weather in
                weather.currentDate >= today
            }
        )
        
        do {
            if let todayWeather = try context.fetch(descriptor).first {
                return todayWeather.uvIndex(at: hour)
            }
        } catch {
            print("UV ÏßÄÏàò Ï°∞Ìöå Ïã§Ìå®: \(error)")
        }
        
        return 0.0
    }
    
    /// ÏãúÍ∞Ñ Î≤îÏúÑÏùò ÌèâÍ∑† UV ÏßÄÏàò Í∞ÄÏ†∏Ïò§Í∏∞
    func getAverageUVIndex(from startHour: Int, to endHour: Int) async -> Double {
        guard let context = modelContext else { return 0.0 }
        
        let today = Calendar.current.startOfDay(for: Date())
        let descriptor = FetchDescriptor<DailyWeatherCache>(
            predicate: #Predicate { weather in
                weather.currentDate >= today
            }
        )
        
        do {
            if let todayWeather = try context.fetch(descriptor).first {
                return todayWeather.averageUVIndex(from: startHour, to: endHour)
            }
        } catch {
            print("ÌèâÍ∑† UV ÏßÄÏàò Ï°∞Ìöå Ïã§Ìå®: \(error)")
        }
        
        return 0.0
    }
    
    /// Ïò§Îäò ÎÇ†Ïî® Ï∫êÏãúÍ∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
    var hasTodayWeatherCache: Bool {
        guard let context = modelContext else { return false }
        
        let today = Calendar.current.startOfDay(for: Date())
        let descriptor = FetchDescriptor<DailyWeatherCache>(
            predicate: #Predicate { weather in
                weather.currentDate >= today
            }
        )
        
        do {
            let results = try context.fetch(descriptor)
            return !results.isEmpty
        } catch {
            return false
        }
    }
    
    /// ÌòÑÏû¨ ÎèÑÏãú Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
    var currentCity: String {
        guard let context = modelContext else { return "Ïïå Ïàò ÏóÜÏùå" }
        
        let today = Calendar.current.startOfDay(for: Date())
        let descriptor = FetchDescriptor<DailyWeatherCache>(
            predicate: #Predicate { weather in
                weather.currentDate >= today
            }
        )
        
        do {
            if let todayWeather = try context.fetch(descriptor).first {
                return todayWeather.city
            }
        } catch {
            print("ÎèÑÏãú Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®: \(error)")
        }
        
        return "Ïïå Ïàò ÏóÜÏùå"
    }
    
    /// ÏùºÏ∂ú/ÏùºÎ™∞ ÏãúÍ∞Ñ Ï†ïÎ≥¥
    var sunTimes: (sunrise: Date?, sunset: Date?) {
        guard let context = modelContext else { return (nil, nil) }
        
        let today = Calendar.current.startOfDay(for: Date())
        let descriptor = FetchDescriptor<DailyWeatherCache>(
            predicate: #Predicate { weather in
                weather.currentDate >= today
            }
        )
        
        do {
            if let todayWeather = try context.fetch(descriptor).first {
                return (todayWeather.sunrise, todayWeather.sunset)
            }
        } catch {
            print("ÏùºÏ∂ú/ÏùºÎ™∞ Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®: \(error)")
        }
        
        return (nil, nil)
    }
}
